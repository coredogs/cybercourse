<?php

/**
 * Implements hook_help().
 */
function characters_help($path, $arg) {
  switch ($path) {
      // Help for another path in the block module
    case 'admin/help#characters':
      return '<p>' . t('Helpy help help, <a href="@jquery">jQuery</a>.', 
          array(
            '@jquery' => 'http://jquery.com',
          )) . '</p>';
  }
}


/**
 * Implements hook_menu().
 */
function characters_menu() {
//  $items['admin/content/characters'] = array(
//    'title' => 'Characters',
//    'description' => 'Create, edit, and delete characters and poses.',
//    'page callback' => 'characters_admin',
//    'access arguments' => array('administer characters'),
//    'type' => MENU_NORMAL_ITEM,
//    'file' => 'characters.admin.inc',
//  );
  $items['characters/sheets'] = array(
    'title' => 'Character sheets',
    'description' => 'See a list of characters.',
    'page callback' => 'characters_show_character_sheet_list',
    'access callback' => 'characters_check_access_sheets',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['characters/sheets/%'] = array(
    'title callback' => 'characters_sheet_title',
    'title arguments' => array(2),
    'description' => 'See poses for a character.',
    'page callback' => 'characters_show_character_sheet',
    'page arguments' => array(2),
    'access callback' => 'characters_check_access_sheets',
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}


function characters_sheet_title( $nid ) {
  $node = node_load($nid);
  $title = t( 'Character sheet for @name', array('@name' => $node->title) );
  return $title;
}

/**
 * Implementation of hook_perm().
 */
function characters_permission() {
  return array(
    'administer characters' => array(
      'title' => t('Administer characters'),
      'description' => t('Create, delete, and update characters.')
    ),
    'view character sheets' => array(
      'title' => t('View character sheets'),
      'description' => t('See characters and poses.')
    ),
  );
}

/**
* Implements hook_entity_info_alter().
*/
function characters_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['character_sheet'] = array(
    'label' => t('Character sheet'),
    'custom settings' => TRUE,
  );
}


function characters_check_access_sheets() {
  return 
         user_access('administer characters') 
      || user_access('view character sheets');
}

/**
 * Show a list of links to character sheets.
 */
function characters_show_character_sheet_list() {
  //Fetch character data.
  $query = new EntityFieldQuery;
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'character')
    ->propertyCondition('status', 1)
    ->propertyOrderBy('title');
  $query_result = $query->execute();
  //Fetch the character names.
  $characters = array();
  foreach ( $query_result['node'] as $nid => $value ) {
    $node = node_load($nid);
    $characters[$nid] = $node->title;
  }
  //Show the characters.
  $output = array();
  if ( sizeof( $characters ) == 0 ) {
    //There are no characters to show.
    $output['no characters'] = array(
      '#type' => 'markup',
      '#markup' => '<p>' . t('No characters have been created yet.') . '</p>',
    );
    return $output;
  }
  else {
    //There are characters to show.
    $output['intro'] = array(
      '#type' => 'markup',
      '#markup' => 
             '<p>' 
           .   ( sizeof( $characters ) == 1 )
                  ? t('Here is the character that has been created.') 
                  : t('Here are the characters that have been created.') 
           . '</p>',
    );
    global $base_url;
    foreach ( $characters as $nid => $title ) {
      $output[$nid] = array(
        '#type' => 'markup',
        '#markup' => 
              '<p class="character-link">'
              . l( check_plain( $title ),  
                   $base_url . '/characters/sheets/' . $nid 
                 )
            . '</p>'
      );
    } 
  } //End there are characters to show.
  return $output;
}

/**
 * Show a character sheet.
 * @param integer $char_nid The nid of the character to show.
 */
function characters_show_character_sheet( $char_nid ) {
  //Load the node.
  $node = node_load( $char_nid );
  //Show it, using a special view mode.
  $output = node_view($node, 'character_sheet');
  if ( isset( $output['#contextual_links'] ) ) {
    unset( $output['#contextual_links'] );
  }
  if ( isset( $output['links'] ) ) {
    unset( $output['links'] );
  }
  return $output;
}


/**
* Implements hook_filter_info().
*/
function characters_filter_info() {
  $filters['filter_characters'] = array(
    'title' => t('Characters'),
    'description' => t('Replace character tokens'),
//    'prepare callback' => '_dgd7_tip_prepare',
    'process callback' => 'characters_process_filter',
//    'tips callback' => 'swim_tips',
  );
  return $filters;
}


function characters_process_filter($text, $filter, $format = 'characters', $langcode = 'und') {
//  $valid_content_types = array(
//    'blueprint', 'blueprint_page',
//    'course', 'course_page',
//    'knowledge_map_item',
//    'site_page'
//  );
//  //In a content type where character refs are allowed?
//  if ( in_array( $node->type, $valid_content_types ) ) {
//    $content = $node->body[LANGUAGE_NONE][0]['value'];
    //Find all the characters on the page that are referred to.
    $regex_matches = array();
    $regex_match_count = preg_match_all("/\{\s*character\s*\:\s*(.*?)\s*\}/i", 
        $text, $regex_matches);
    if ( $regex_match_count > 0 ) {
      //Look up data for those characters.
      $token_list = '';
      foreach( $regex_matches[1] as $key => $match ) {
        if ( $key > 0 ) {
          $token_list .= ', ';
        }
        $token_list .= '\'' . check_plain($match) . '\'';
      }
      $sql = '
          select field_token_value, field_caption_value, 
            field_image_alt, field_image_width, field_image_height,
            field_image_fid, file_managed.uri as uri
          from field_data_field_token 
            left join field_data_field_caption on 
              field_data_field_token.entity_id 
              = field_data_field_caption.entity_id
            left join field_data_field_image on 
              field_data_field_token.entity_id
              = field_data_field_image.entity_id
            inner join file_managed on file_managed.fid = field_image_fid
          where 
            field_data_field_token.bundle = \'character_pose\'
            and field_token_value in ( ' . $token_list . ' )
      ';
      $query_result = db_query($sql); //, array( ':token_list' => $token_list ));
      if ( $query_result->rowCount() > 0 ) {
        //Make an array of substitutions.
        //Each entry has two parts:
        //1. Token spec found in content.
        //2. Complete HTML for it.
        $substitutions = array();
        foreach ( $regex_matches[1] as $regex_key => $regex_match ) {
          //Find the token in the query result array.
          $html = '';
          foreach ( $query_result as $row ) {
            //Must have a URI.
            if ( $row->uri ) {
              if ( $regex_match == $row->field_token_value ) {
                //Compute the HTML.
                $html = _characters_compute_char_html( $row );
                //Add to substitutions array.
                $substitutions[] = array(
                  'matched' => $regex_matches[0][$regex_key],
                    //Note: this is the entire matched text, not the token.
                  'replacement' => $html,
                );
                break;
              } //End if match
            } //End there is a URI.
          } //Loop across query results.
        } //Loop across matches.
        //Apply the substitutions.
        foreach ( $substitutions as $substitution ) {
          $text = str_replace(
              $substitution['matched'], 
              $substitution['replacement'], 
              $text
          );
        }
        //Count the closing tags.
        $pattern = '/\{\s*\/\s*character\s*\}/i';
          //{, white space, /, white space, 'character', white space, }
        $closing_matches = array();
        $closing_tag_count = preg_match_all($pattern, $text, $closing_matches);
        if ( $closing_tag_count != $regex_match_count ) {
          drupal_set_message(
              'Please check for a missing or incorrect character closing tag.', 
              'warning'
          );
        }
        //Replace the close tags.
        $text = preg_replace($pattern, '</div>', $text);
        //Store result in node object.
      } //End there were query results.
    } //End there were regex matches.
  return $text;
//  } //End this is a content type that allows characters.
}

/*
 * Create HTML for a character.
 */
function _characters_compute_char_html( $query_result ) {
  $html = '
<div class="cyco_character" markdown="1">
  <figure>
    <img src="' . file_create_url( $query_result->uri ) . '" 
      alt="' . t( $query_result->field_image_alt ) . '" 
      height="' . check_plain( $query_result->field_image_height ) . '"
      width="' . check_plain( $query_result->field_image_width ) . '"
    >
  </figure>
  <figcaption>' . t($query_result->field_caption_value) . '</figcaption>';
  return $html;
}