<?php
/**
 * Flag showing whether the poses preview data (used with CKEditor) is dirty.
 */
define('POSES_PREVIW_DIRTY_FLAG_VAR', 'characters_poses_preview_dirty');
/**
 * Poses preview data used with CKEditor.
 */
define('POSES_PREVIEW_DATA_VAR', 'characters_poses_preview_data');

/**
 * Implements hook_help().
 */
function characters_help($path, $arg) {
  switch ($path) {
      // Help for another path in the block module
    case 'admin/help#characters':
      return '<p>' . t('Helpy help help, <a href="@jquery">jQuery</a>.', 
          array(
            '@jquery' => 'http://jquery.com',
          )) . '</p>';
  }
}


/**
 * Implements hook_menu().
 */
//function characters_menu() {
//  $items['characters/sheets'] = array(
//    'title' => 'Character sheets',
//    'description' => 'See a list of characters.',
//    'page callback' => 'characters_show_character_sheet_list',
//    'access callback' => 'characters_check_access_sheets',
//    'type' => MENU_NORMAL_ITEM,
//  );
//  $items['characters/sheets/%'] = array(
//    'title callback' => 'characters_sheet_title',
//    'title arguments' => array(2),
//    'description' => 'See poses for a character.',
//    'page callback' => 'characters_show_character_sheet',
//    'page arguments' => array(2),
//    'access callback' => 'characters_check_access_sheets',
//    'type' => MENU_NORMAL_ITEM,
//  );
//  return $items;
//}


//function characters_sheet_title( $nid ) {
//  $node = node_load($nid);
//  $title = t( 'Character sheet for @name', array('@name' => $node->title) );
//  return $title;
//}

/**
 * Implementation of hook_perm().
 */
function characters_permission() {
  return array(
    'administer characters' => array(
      'title' => t('Administer characters'),
      'description' => t('Create, delete, and update characters.')
    ),
//    'view character sheets' => array(
//      'title' => t('View character sheets'),
//      'description' => t('See characters and poses.')
//    ),
    'use characters in content' => array(
      'title' => t('Use characters in content'),
      'description' => t('Insert character token in content.')
    ),
  );
}

/**
* Implements hook_entity_info_alter().
*/
//function characters_entity_info_alter(&$entity_info) {
//  $entity_info['node']['view modes']['character_sheet'] = array(
//    'label' => t('Character sheet'),
//    'custom settings' => TRUE,
//  );
//}
//
//
//function characters_check_access_sheets() {
//  return 
//         user_access('administer characters') 
//      || user_access('view character sheets');
//}

/**
 * Show a list of links to character sheets.
 */
//function characters_show_character_sheet_list() {
//  //Fetch character data.
//  $query = new EntityFieldQuery;
//  $query
//    ->entityCondition('entity_type', 'node')
//    ->entityCondition('bundle', 'character')
//    ->propertyCondition('status', 1)
//    ->propertyOrderBy('title');
//  $query_result = $query->execute();
//  //Fetch the character names.
//  $characters = array();
//  foreach ( $query_result['node'] as $nid => $value ) {
//    $node = node_load($nid);
//    $characters[$nid] = $node->title;
//  }
//  //Show the characters.
//  $output = array();
//  if ( sizeof( $characters ) == 0 ) {
//    //There are no characters to show.
//    $output['no characters'] = array(
//      '#type' => 'markup',
//      '#markup' => '<p>' . t('No characters have been created yet.') . '</p>',
//    );
//    return $output;
//  }
//  else {
//    //There are characters to show.
//    $output['intro'] = array(
//      '#type' => 'markup',
//      '#markup' => 
//             '<p>' 
//           .   ( sizeof( $characters ) == 1 )
//                  ? t('Here is the character that has been created.') 
//                  : t('Here are the characters that have been created.') 
//           . '</p>',
//    );
//    global $base_url;
//    foreach ( $characters as $nid => $title ) {
//      $output[$nid] = array(
//        '#type' => 'markup',
//        '#markup' => 
//              '<p class="character-link">'
//              . l( check_plain( $title ),  
//                   $base_url . '/characters/sheets/' . $nid 
//                 )
//            . '</p>'
//      );
//    } 
//  } //End there are characters to show.
//  return $output;
//}

/**
 * Show a character sheet.
 * @param integer $char_nid The nid of the character to show.
 */
//function characters_show_character_sheet( $char_nid ) {
//  //Load the node.
//  $node = node_load( $char_nid );
//  //Show it, using a special view mode.
//  $output = node_view($node, 'character_sheet');
//  if ( isset( $output['#contextual_links'] ) ) {
//    unset( $output['#contextual_links'] );
//  }
//  if ( isset( $output['links'] ) ) {
//    unset( $output['links'] );
//  }
//  return $output;
//}


/**
* Implements hook_filter_info().
*/
function characters_filter_info() {
  $filters['filter_characters'] = array(
    'title' => t('Characters'),
    'description' => t('Replace character tokens'),
    'process callback' => 'characters_process_filter',
  );
  return $filters;
}


function characters_process_filter($text, $filter, $format = 'characters', $langcode = 'und') {
  //Find all the characters on the page that are referred to.
  $regex_matches = array();
  $regex_match_count = preg_match_all("/\[\s*character\s*\:\s*(.*?)\s*\]/i", 
      $text, $regex_matches);
  if ( $regex_match_count > 0 ) {
    //Look up data for those characters.
    $token_list = '';
    foreach( $regex_matches[1] as $key => $match ) {
      if ( $key > 0 ) {
        $token_list .= ', ';
      }
      $token_list .= '\'' . check_plain($match) . '\'';
    }
    $sql = '
        select field_token_value, field_caption_value, 
          field_image_alt, field_image_width, field_image_height,
          field_image_fid, file_managed.uri as uri
        from field_data_field_token 
          left join field_data_field_caption on 
            field_data_field_token.entity_id 
            = field_data_field_caption.entity_id
          left join field_data_field_image on 
            field_data_field_token.entity_id
            = field_data_field_image.entity_id
          inner join file_managed on file_managed.fid = field_image_fid
          inner join node on field_data_field_token.entity_id
            = node.nid
        where 
          node.status = 1
          and field_data_field_token.bundle = \'character_pose\'
          and field_token_value in ( ' . $token_list . ' )
    ';
    $query_result = db_query($sql); //, array( ':token_list' => $token_list ));
    if ( $query_result->rowCount() > 0 ) {
      //Make an array of substitutions.
      //Each entry has two parts:
      //1. Token spec found in content.
      //2. Complete HTML for it.
      $substitutions = array();
      foreach ( $regex_matches[1] as $regex_key => $regex_match ) {
        //Find the token in the query result array.
        $html = '';
        foreach ( $query_result as $row ) {
          //Must have a URI.
          if ( $row->uri ) {
            if ( $regex_match == $row->field_token_value ) {
              //Compute the HTML.
              $html = _characters_compute_char_html( $row );
              //Add to substitutions array.
              $substitutions[] = array(
                'matched' => $regex_matches[0][$regex_key],
                  //Note: this is the entire matched text, not the token.
                'replacement' => $html,
              );
              break;
            } //End if match
          } //End there is a URI.
        } //Loop across query results.
      } //Loop across matches.
      //Apply the substitutions.
      foreach ( $substitutions as $substitution ) {
        $text = str_replace(
            $substitution['matched'], 
            $substitution['replacement'], 
            $text
        );
      }
      //Count the closing tags.
      $pattern = '/\[\s*\/\s*character\s*\]/i';
        //{, white space, /, white space, 'character', white space, }
      $closing_matches = array();
      $closing_tag_count = preg_match_all($pattern, $text, $closing_matches);
      if ( $closing_tag_count != $regex_match_count ) {
        drupal_set_message(
            'Please check for a missing or incorrect character closing tag.', 
            'warning'
        );
      }
      //Replace the close tags.
      $text = preg_replace($pattern, '</div>', $text);
      //Store result in node object.
    } //End there were query results.
  } //End there were regex matches.
  return $text;
}

/*
 * Create HTML for a character.
 */
function _characters_compute_char_html( $query_result ) {
  $html = 
'<div class="cyco_character" markdown="1">'
  . '<div class="cyco_character_figure">'
  .   '<img src="' . file_create_url( $query_result->uri ) . '" '
  .     'alt="' . t( $query_result->field_image_alt ) . '"  '
  .     'height="' . check_plain( $query_result->field_image_height ) . '" '
  .     'width="' . check_plain( $query_result->field_image_width ) . '" '
  .   '>' 
  .   '<div class="cyco_character_figcaption">' 
  .     t($query_result->field_caption_value) 
  .   '</div>'
  . '</div>';
  return $html;
}


function characters_get_editor_previews() {
  $characters_preview_dirty = variable_get(POSES_PREVIW_DIRTY_FLAG_VAR, TRUE);
  if ( $characters_preview_dirty ) {
    _characters_generate_ck_select_data();
  }
  return variable_get(POSES_PREVIEW_DATA_VAR, 'none');
}

/*
 * Create HTML for a character.
 */
//Bugs in markdown library's <figure> handling, so use divs above.
//function _characters_compute_char_html( $query_result ) {
//  $html = 
//'<div class="cyco_character" markdown="1">'
//  . '<figure>'
//  .   '<img src="' . file_create_url( $query_result->uri ) . '" '
//  .     'alt="' . t( $query_result->field_image_alt ) . '"  '
//  .     'height="' . check_plain( $query_result->field_image_height ) . '" '
//  .     'width="' . check_plain( $query_result->field_image_width ) . '" '
//  .   '>' 
//  .   '<figcaption>' 
//  .     t($query_result->field_caption_value) 
//  .   '</figcaption>'
//  . '</figure>';
//  return $html;
//}


function _characters_generate_ck_select_data() {
  //Fetch character pose data.
  $query = new EntityFieldQuery;
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'character_pose')
    ->propertyCondition('status', 1)
    ->fieldOrderBy('field_token', 'value');
  $query_result = $query->execute();
  //Fetch the character names.
  $character_pose_previews = array();
  foreach ( $query_result['node'] as $nid => $value ) {
    $node = node_load($nid);
    $token = $node->field_token[LANGUAGE_NONE][0]['safe_value'];
    //Caption is not a required field.
    if ( isset($node->field_caption[LANGUAGE_NONE][0]['safe_value']) ) {
      $caption = $node->field_caption[LANGUAGE_NONE][0]['safe_value'];
    }
    else {
      $caption = '';
    }
    $uri = $node->field_image[LANGUAGE_NONE][0]['uri'];
    $usable_url = file_create_url( $uri );
    $preview_html = 
        '<div class="characters_ck_preview">'
        . '<div class="characters_ck_preview_image">'
        .   '<img src="' . $usable_url . '" alt="' . $caption . '">'
        .   '<div class="characters_ck_preview_caption">'
        .     $caption
        .   '</div>'
        .  '</div>'
        .  '<div class="characters_ck_preview_token">'
        .     'Token:<br>' . $token . '<br><br>'
        .  '</div>'
        .'</div>'
      ;
    $character_pose_previews[] = array(
      'token' => $token,
      'caption' => $caption,
      'html' => $preview_html,
    );
  }
  if ( sizeof($character_pose_previews) == 0 ) {
    variable_set(POSES_PREVIEW_DATA_VAR, 'none');
  }
  else {
    variable_set( POSES_PREVIEW_DATA_VAR, $character_pose_previews );
  }
  variable_set(POSES_PREVIW_DIRTY_FLAG_VAR, FALSE);
}

function characters_node_update( $node ) {
  _characters_set_dirty_flag( $node );
}

function characters_node_delete( $node ) {
  _characters_set_dirty_flag( $node );
}

function characters_node_insert( $node ) {
  _characters_set_dirty_flag( $node );
}

function _characters_set_dirty_flag( $node ) {
  if ( $node->type == 'character_pose' ) {
    //Mark character pose preview data used in editor as dirty.
    variable_set(POSES_PREVIW_DIRTY_FLAG_VAR, TRUE);
  }  
}


function characters_form_alter(&$form, &$form_state, $form_id) {
  // @todo Instead of checking form_id, check for a field
  //having the SWIM format? Cache the results of the check 
  //so don't run check again on this page call.
  //Not sure if this is the right approach.
  if ( stristr($form_id, 'node_form') !== FALSE ) {
    _characters_load_client_side_stuff();
  }
}

/**
 * Add client-side stuff the character code needs.
 */
function _characters_load_client_side_stuff() {
  drupal_add_css(drupal_get_path('module', 'characters') . '/css/characters.css' );
  global $base_url;
  $settings = array(
    'base_url' => $base_url,
    'pose_previews' => characters_get_editor_previews(),
    'pose_stylesheet' => 
        drupal_get_path('module', 'characters') . '/css/characters.css',
  );
  drupal_add_js(
      array('characters' => $settings),
      'setting'
  );
}

/**
 * Implements hook_form_alter().
 */
function characters_form_character_pose_node_form_alter( &$form, &$form_state ) {
  $form['#validate'][] = '_character_validate_pose_form';
}

/**
 * Validate the pose data.
 */
function _character_validate_pose_form( &$form, &$form_state ) {
  $token 
      = $form_state['values']['field_token'][LANGUAGE_NONE][0]['value'];
  // Verify that the token contains no disallowed characters.
  if ( preg_match('/[^a-z0-9_]/', $token) ) {
    form_set_error(
        'field_token', 
        t(  'Sorry, the token can contain only lowercase letters, numbers, '
          . 'and underscores (_). E.g., "alia_hi".'
        )
    );
    return;
  }
  //Check that the token in unique.
  //Find nodes using that token.
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'character_pose')
    ->fieldCondition('field_token', 'value', $token);
  $result = $query->execute();
  if ( isset( $result['node'] ) ) {
    //There is at least one node using the token.
    if ( sizeof($result['node']) > 1 ) {
      throw new Exception('Characters module: duplicate tokens!');
    }
    list($nid) = array_keys($result['node']);
    //Error if it is some other node.
    if ( $form['#node']->nid != $nid ) {
      form_set_error(
          'field_token', 
          t(   'Sorry, the value "' . $token . '" is already in use. Tokens must ' 
             .  'be unique, e.g., "' . $token . '2".'
           )
      );
      return;
    }
  } // End token in use.
}


